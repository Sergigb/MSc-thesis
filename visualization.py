import pickle
import os
import json

import numpy as np
from sklearn.manifold import TSNE
import torchvision.transforms as transforms
import torch
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox

from model import CNN
from data_loader import get_wiki_data_loader

use_lda_labels = False  # use the labels generated by the LDA instead of the neural network
mixture_mode = True


def imscatter(x, y, image, ax=None, zoom=2.):
    if ax is None:
        ax = plt.gca()
    try:
        image = plt.imread(image)
    except TypeError:
        pass
    im = OffsetImage(image, zoom=zoom, cmap=plt.get_cmap('gray'))
    x, y = np.atleast_1d(x, y)
    artists = []
    for x0, y0 in zip(x, y):
        ab = AnnotationBbox(im, (x0, y0), xycoords='data', frameon=False)
        artists.append(ax.add_artist(ab))
    ax.update_datalim(np.column_stack([x, y]))
    ax.autoscale()
    return artists

if use_lda_labels:
    emb_filename = 'data/2d-embeddings-lda.npy'
    ids_filename = 'data/ids-embeddings-lda.pkl'
else:
    emb_filename = 'data/2d-embeddings-mdn10-1.npy'
    ids_filename = 'data/ids-embeddings-mdn10-1.pkl'

if os.path.isfile(emb_filename):
    X_embedded = np.load(emb_filename)
    with open(ids_filename, 'rb') as handle:
        ids = pickle.load(handle)
else:
    if use_lda_labels:
        json_path = 'LDA/training_labels40_original.json'
        with open(json_path) as f:
            labels = json.load(f)
        ids = list(labels.keys())

        X = []
        for id_ in ids:
            X.append(labels[id_])

        print(len(X))
        X = np.array(X)
        print(X.shape)
        print(len(ids))

        with open(ids_filename, 'wb') as handle:
            pickle.dump(ids, handle, protocol=pickle.HIGHEST_PROTOCOL)

        X_embedded = TSNE(n_components=2, perplexity=40, early_exaggeration=24.0, verbose=1,
                          learning_rate=500.0).fit_transform(X)
        print(X_embedded.shape)
        np.save(emb_filename, X_embedded)
    else:
        transform = transforms.Compose([
            transforms.Resize((227, 227)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                 std=[0.229, 0.224, 0.225])
            ])

        batch_size = 512

        dataset_path = './../datasets/ImageCLEF_wikipedia/'
        json_labels_path = 'LDA/training_labels40_original.json'

        data_loader = get_wiki_data_loader(dataset_path, json_labels_path,
                                           transform, batch_size, shuffle=True,
                                           num_workers=4, return_ids=True)

        model_path = 'models/mdn-1kernel10.pth'
        model = CNN(40, 1, out_dim=256, mixture_model=mixture_mode)
        model.load_state_dict(torch.load(model_path))
        model.eval()

        if torch.cuda.is_available():
            model.cuda()

        X = []
        ids = []

        for step, (images, _, image_ids) in enumerate(data_loader):
            if torch.cuda.is_available():
                images = images.cuda()

            if mixture_mode:
                _, _, out = model(images)
            else:
                out = model(images)

            ids.extend(list(image_ids))
            for i in range(out.shape[0]):
                X.append(out[i, :].cpu().detach().numpy())

            print('Step ' + str(step+1) + '/' + str(len(data_loader)))
        print(len(X))
        X = np.array(X)
        print(X.shape)
        print(len(ids))

        with open(ids_filename, 'wb') as handle:
            pickle.dump(ids, handle, protocol=pickle.HIGHEST_PROTOCOL)

        X_embedded = TSNE(n_components=2, perplexity=40, early_exaggeration=24.0, verbose=1, learning_rate=500).fit_transform(X)
        print(X_embedded.shape)
        np.save(emb_filename, X_embedded)

        print("finished!")

fig, ax = plt.subplots()
for i in range(10000):
    idx = int(np.random.choice(len(ids), 1))
    image_filename = ids[idx]
    image_filename = os.path.join('./../datasets/ImageCLEF_wikipedia/', image_filename)
    imscatter(X_embedded[idx, 0], X_embedded[idx, 1], image_filename, zoom=0.20)

plt.show()


    




